# 第19节：原始类型与引用类型

### 一、基本概念

JavaScript有六种数据类型，即数值型，字符串型，布尔型，Null，Undefined，和对象。

按照存储方式分为两类：

* 原始类型（值类型）： 数值，字符串，布尔, Null， Undefined。
* 引用类型：对象

原始类型：赋值给变量，存储的是这个值本身。

引用类型：赋值给变量，存储的是一个引用，而这个引用会指向内存中的这个对象。

### 二、原始类型与引用类型的区别

#### 案例1. 赋值的区别

```js
// 先看值类型
var str1 = "hello world";
var str2 = str1; //表明这里赋值的是值本身
str1 = "hello js";

console.log(str1);//"hello js"
console.log(str2);//"hello world"

//再看引用类型
var obj1 = {name:"xiaoming"};
var obj2 = obj1; // 表明赋值的是一个引用，不同的变量指向同一个对象
obj1.name = "xiaohong";

console.log(obj1.name); // "xiaohong"
console.log(obj2.name); // "xiaohong"
```

#### 案例2. 比较的区别

```js
var str1 = "hello world";
var str2 = "hello world";
console.log(str1 == str2);  //true ,比较的是值，同一个值当然相等

var obj1 = {name:"xiaoming"};
var obj2 = {name:"xiaoming"};
console.log(obj1 == obj2); //false, 内容相同但是不同的引用，比较的是引用，因此为false
```

#### 案例3.  传参的区别

```js
// 值类型为参数
var str = "hello world";
function fun(s){
    s = "hello js";
}
fun(str);
console.log(str);  //hello world 表示值不变

//引用类型为参数
var obj = {name:"xiaoming"};
function fun(o){
    o.name = "xiaohong";
}
fun(obj);
console.log(obj.name); // "xiaohong" 表示传递的引用类型参数会因为操作而发生相应的变化
```

### 三、对象的浅度克隆

要求：获得一个对象的克隆对象，两者属性相同，修改其中一个对象不会影响另一个。

函数：参数是一个对象，返回值是这个对象的克隆对象。

for...in语句可以遍历对象的属性，并且通过obj[属性]来获得属性值，因此可以实现克隆

```js
var student = {name:"xiaoming", age:2, sex:"male"};
for(var i in student){  //可以遍历对象的属性，同时获取到值
    console.log("属性:"+i);
    console.log("属性值"+student[i]);
}

function clone(obj){
    var newObj = {};  //创建克隆对象
    for(var i in obj){ // 遍历对象
        newObj[i] = obj[i]; //将传进来对象的属性和值赋值给克隆对象
    }
    return newObj;//返回克隆对象
}
var studentClone = clone(student);
student.name = "xiaohong";
console.log(student.name);
console.log(studentClone.name); // 两者没有联系了
```

我们发现这个例子对象的属性值是原始类型，如果将对象的某个属性改为引用类型，那么通过这种方式克隆的对象在这个引用属性上还是有联系，即这个属性指向同一块内存，当改变一者时另一个也会变。因此这是浅度克隆。