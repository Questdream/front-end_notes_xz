# 第04节：跨域请求

### 一、同源策略

**相同的ip（域名），相同的端口，则为同源，否则为不同源**

同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互，用于隔离潜在恶意文件的重要安全机制。

比如xyz.com下的js脚本采用ajax读取abc.com里面的文件数据是会被拒绝的。

### 二、jsonp原理

ajax在默认情况下式不可以跨域的，但是script标签可以通过src属性获取到跨域的js文件。

因此，我们吧数据装载到js文件中，然后通过script标签跨域引入到当前项目中，进而使用跨域数据。

```js
//通过script标签进行跨域请求
1.在本地开启两个服务器，端口分别是8080和3000，一个可以用http-server，一个用nodemon启动
2.把待获取的数据放在3000端口服务器的一个js文件中
3.3000端口服务器的前端页面引入8080端口服务器的js文件
4.然后就可以使用3000端口服务器的这个js数据了。
```

需要注意的是，jsonp本质是并不是ajax，但是功能很像，jsonp封装在了ajax中（好像）。

使用jQuery的ajax方法的jsonp方法完成跨域请求数据。

```js
// 后台部分程序
const jsonp = require("koa-jsonp");//npm install --save koa-jsonp
app.use(jsonp());

router.get("/data",ctx => {
    ctx.body = "hello jsonp"
});
// 前端页面请求程序
$.ajax({
    url:"http://127.0.0.1:3000/data",
    dataType:"jsonp"// 之前写的type："get"就不能获取到跨域数据，必须使用jsonp
}).done( res => {
    console.log(res);//跨域请求到数据
})

```

jsonp需要前后端都设置好程序才能完成跨域请求，其本身也是get请求

而跨域处理一些post请求等就无法使用jsonp了。可以通过设置响应头来提高跨域请求功能。

### 三、设置响应头

很多时候在制作一个前后端分离的项目时，开发过程是需要跨域的，

但是项目部署后不需要跨域，这个时候我们可以设置响应头服务器允许跨域，部署后再去掉此响应头属性即可

通过设置http协议的响应头部属性Access-Control-Allow-Origin可以允许其他服务器对本服务进行跨域请求。

```js
router.get("/getdata", async (ctx) => {
    ctx.set("Access-Control-Allow-Origin", "http://127.0.0.1:8080");//这里第一个为跨域请求属性，第二个是值，表示可以跨域请求的服务器，若为"*”则表示所有服务器都可以跨域请求本网址
    ctx.body = "data"
})
```

设置之后，/getdata这个接口就允许跨域请求了。

#### 总结

跨域请求的三种方式：

1. 通过script获取相应的js文件
2. 通过jsonp方式，获取get请求
3. 设置响应头属性Access-Control-Allow-Origin