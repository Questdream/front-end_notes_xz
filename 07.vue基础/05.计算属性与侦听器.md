# 第05节：计算属性与侦听器

### 一、计算属性

计算属性中定义的值可以直接绑定咋表达式汇总，如果某些值需要通过计算才能得到，那使用计算属性就很合适。

```js
<template>
    <div>
    	<h1>{{fullTitle}}</h1>
		<h2>{{title}}</h2>
	</div>
</template>

export default {
    data(){
        return {
            title:"hello world"
        }
    },
    computed:{
        fullTitle(){
            return "xzgb"+ this.title
        }
    }
}
```

可以看到fullTitle的值是通过title属性计算而来，所以通过compute获得计算结果，然后绑定到表达式中。

还有计数器例子：

```js
<template>
    <div id="app">
        <div>单价{{price}}</div>
		<div>
            <button @click="sub">-</button>
			<span>{{count}}</span>
			<button @click="add">+</button>
		</div>
		<div>总价：{{totalPrice}}</div>
	</div>
</template>

//这里我们可以把price和count属性定义在data属性中，totalPrice属性定义在计算属性中,其实就是一个方法，此属性的属性值就是此方法的返回值。

export default {
    name:"app",
    data(){
        return {
            name:"lxx",
            count:0,
            price:15
        }
    },
    computed:{
        totalPrice(){
            return this.count*this.price
        }
    }，
    methods:{
    	add(){
            this.count++
        },
        sub(){
            this.count--
        }
	}
}
```

### 二、侦听属性

侦听属性可以实时监控一个属性的变化，如果这个值发生变化了，可以执行某些操作，我们用侦听器来改写上面计数器的功能：

```js
export default {
    name:"app",
    data(){
        return {
            name:"lxx",
            count:0,
            price:15,
            totalPrice:0
        }
    },
    watch:{
        count(newValue,oldValue){//count同上面data中定义的count属性，就是侦听这个属性，第一个参数变化之后的值，第二个参数是变化之前的值
            console.log(newValue);
            console.log(oldValue);
            this.totalPrice = newValue*this.price
        }
    },
    methods:{
        add(){
            this.count++
        },
        sub(){
            this.count--
        }
    }
}
```

### 三、计算属性与侦听属性对比

如果关注的是一个变量的结果，使用计算属性；

如果关注一个变量的改变会导致一系列行为，使用侦听属性。

